# 线程的几种状态转换

http://www.cnblogs.com/jijijiefang/articles/7222955.html

- 新建状态new:新创建了一个线程对象

- 就绪状态Runnable:线程对象创建后,其他线程调用了该对象的start()方法,该状态的线程位于可运行线程池中,变得可运行,只等待获取cpu的使用权,即在就绪状态的进程除cpu之外,其他的运行所需资源都已全部获得.

- 运行状态running:就绪状态的线程获取了cpu,执行程序代码

- 阻塞状态blocked:阻塞状态是线程因为某种原因放弃cpu使用权,暂时停止运行.知道线程进入就绪状态后,才有机会转到运行状态

  - 阻塞分为三种
  - 等待阻塞:运行的线程执行wait()方法,改线程会释放占用的所有资源,JVM会把该线程放入'等待池'中,进入这个状态后,是不能自动唤醒的,必须依靠其他线程调用notify()或者notifyAll()方法才能被唤醒
  - 同步阻塞:运行的线程在获取对象的同步锁时若该同步锁被别的线程占用,则jvm会把该线程放入'锁池'中
  - 其他阻塞:运行的线程执行sleep()或join()方法,或者发出了i/o请求时,jvm会把该线程置为阻塞状态,当sleep()状态超时,join()等待线程终止或者超时,或者i/o处理完毕时,线程重新转入就绪状态.

- 死亡状态Dead:线程执行完了或者因一场退出了run()方法,该线程结束生命周期

  ![](./images/thread-status-change-cn.png)

- 注:拿到对象的锁标记,即为获得了对该对象(临界区)的使用权限.即该线程获得了运行所需的资源,进入'就绪状态',只需获得cpu,就可以运作.因为当调用wait()后,线程会释放掉它所占有的'锁标志',所以线程只有再次获取资源才能进入就绪状态

## 解释

- 线程的实现有两种方式,一是继承thread类,而是实现runnable接口,但不管怎样,当我们new了这个对象后,线程就进入了初始化状态
- 当该对象调用了start方法,就进入就绪状态
- 进入就绪后,当该对象被操作系统选中,获得cpu时间片就会进入运行状态
- 进入运行状态后就比较复杂了
  - run方法或main方法结束后,线程就进入终止状态
  - 当线程调用了自身的sleep方法或其他线程的join方法,进程让出cpu,然后就会进入阻塞状态(该状态既停止当前线程,但并不释放所占有的资源.即调用sleep函数后,线程不会释放它的'锁标志').当sleep结束或join()结束后,该线程进入可运行状态,继续等待os分配cpu时间片.***典型地,sleep被用在等待某个资源就绪的情形***,测试发现条件不满足后,让线程阻塞一段时间后重新测试,知道条件满足为止.
  - 线程调用了 yield方法,意思是放弃当前获得的cpu时间片,回到就绪状态,这时与其他线程处于同等竞争状态,os有可能会接着又让这个线程进入运行状态;调用yield的效果等价于调度程序认为该线程已执行了足够的时间片从而需要转到另一个线程.***yield只是使当前线程重新回到可执行状态***,所以执行yield的线程有可能在进入到可执行状态后马上又被执行.
  - 当线程刚进入可运行状态,发现将要调用的资源被synchronized(同步),获取不到锁标记,将会立即进入锁池状态,等待获取锁标记(这里的锁池里也许已经有了其他线程在等待获取锁标记,这时他们处于队列状态,即先到先得),一旦线程获得锁标记后,就转入就绪状态,等待os分配cpu时间片
  - suspend和resume方法:两个方法配套使用,suspend是的线程进入阻塞状态,并且不会自动恢复,必须其对应的resume被调用,才能是的线程重新进入可执行状态.典型地,suspend和resume被用在等待另一个线程产生的结果的情形:测试发现结果还没有产生后,让线程阻塞,另一个线程产生了结果后,调用resume使其恢复.
  - wait和notify:当线程调用wait方法后会进入等待队列(进入这个状态会释放所占有的所有的资源,与阻塞状态不同),进入这个状态后,是不能自动唤醒的,必须依靠其他线程调用notify或notifyall方法才能被唤醒(由于notify只唤醒一个线程,但我们并不能确定具体唤醒的是哪一个线程,也许我们需要唤醒的线程不能够被唤醒,因此在实际使用中,一般都使用notifyAll方法,唤醒所有线程),线程被唤醒后会进入锁池,等待获取锁标记
  - wait使线程进入阻塞状态,它有两种形式
    - 一种允许指定以毫秒为单位的一段时间作为参数,当对应的notify被调用或者超出指定的时间,线程重新进入可执行状态---就绪状态
    - 另一种没有参数,必须对应notify调用
    - 当调用wait后,线程释放他所占有的锁标志,从而使线程所在对象中的其他synchronized数据可被别的线程使用.
    - wait和notify 方法因为会对对象的锁标志进行操作,所以他们必须在synchronized函数或synchronizedblock中进行调用,
  - 初看起来,wait,notify和suspend,resume方法对么有什么区别,但事实上他们是截然不同的,区别的核心在于,suspend及其他所有方法在线程阻塞时都不会释放占用的锁,而wait则相反

## 细节上的区别

- 前面说的所有方法都是Thread的,但wait和notify方法是属于object的,也就是说,所有的对象都拥有这一对方法.因为这一对方法阻塞时要释放占用的锁,而锁是任何对象都具有的,调用任意对象的wait方法导致线程阻塞,并且该对象上的锁被释放.而调用任意对象的notify方法则导致因调用该对象的wait方法而阻塞的线程中随机选择的一个解除阻塞(但要等到获得锁后才真正可执行)
- 前面说的所有方法可以在任意位置调用,但wait和notify必须在synchronized或synchronizedblock中调用,只有在synchronized方法或块中当前线程才占有锁,才有锁可以释放,同样的道理,调用这一对方法的对象上的锁必须为当前线程所拥有哦,这样才有锁可以释放.
- 调用notify方法导致解除阻塞的线程是从因调用该对象的wait方法而阻塞的线程中随机选取的,我们无法预料哪一个线程将会被选择,所以编程时要特别小心,避免因这种不确定性而产生问题
- 除了notify,还有一个notifyall也可起到类似作用,唯一的区别在于,notifyAll方法将把因调用该对象的wait方法而阻塞的线程一次性全部解除阻塞,当然,只有获得锁的那个线程才能进入可执行状态

